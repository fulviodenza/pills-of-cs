{
    "pills": [
        {
            "title": "Sharding",
            "body": "Database systems with large data sets or high throughput applications can challenge the capacity of a single server. There are two methods for addressing system growth: **vertical and horizontal scaling. Vertical Scaling: involves increasing the capacity of a single server, such as using a more powerful CPU, adding more RAM, or increasing the storage space. Horizontal Scaling: involves increasing the number of server dividing the system dataset over that servers.",
            "tags": ["database", "memory management"]
        },
        {
            "title": "daily build and smoke test” process",
            "body": "Every file is compiled, linked and combined into an executable program every day, and the program is then put through a “smoke test”, a relatively simple check to see whether the product “smokes” when it runs.",
            "tags": ["testing"]

        },
        {
            "title": "Flood Fill",
            "body": "flooding algorithm that determines and alters the area connected to a given node in a multi-dimensional array with some matching attribute.",
            "tags": ["distributed systems"]
        },
        {
            "title": "Interceptor",
            "body": "a software construct that will break the usual flow of control and allow other code to be executed.",
            "tags": ["software architecture", "programming"]
        },
        {
            "title": "Grid Computing",
            "body": "Constructed as a federation of computer systems, where each system may fall under a different administrative domain, and may be very different when it comes to hardware, software, and deployed network technology.",
            "tags": ["cloud"]
        },
        {
            "title": "On path attack",
            "body": "https://www.cloudflare.com/learning/security/threats/on-path-attack/",
            "tags": ["security"]
        },
        {
            "title": "Thread-Caching Malloc",
            "body": "faster than the glibc 2.3 malloc. TCMalloc implementation takes approximately 50 nanoseconds to execute a malloc/free pair on a 2.8 GHz P4 (for small objects). Reduce lock contention for multi-threaded programs. For small objects, there is virtually zero contention. For large objects, TCMalloc tries to use fine grained and efficient spinlocks. Space-efficient representation of small objects. For example, N 8-byte objects can be allocated while using space approximately 8N * 1.01 bytes. TCMalloc assigns each thread a thread-local cache. Small allocations are satisfied from the thread-local cache. Objects are moved from central data structures into a thread-local cache as needed, and periodic garbage collections are used to migrate memory back from a thread-local cache into the central data structures. TCMalloc treates objects with size <= 32K (small objects) differently from larger objects. Large objects are allocated directly from the central heap using a page-level allocator (a page is a 4K aligned region of memory). I.e., a large object is always page-aligned and occupies an integral number of pages. A run of pages can be carved up into a sequence of small objects, each equally sized. For example a run of one page (4K) can be carved up into 32 objects of size 128 bytes each.",
            "tags": ["memory management", "programming"]
        },
        {
            "title": "Do not return []byte in Go",
            "body": "Returning bytes forces a heap allocation for the returned slice. Since the slice's memory must survive the function's lifespan, the escape analysis has to move it to the heap, where allocations are expensive and put pressure on the garbage collector. Since Go 1.12, the inliner learned how to inline functions that call other functions. We can use this capability to make our allocating APIs as efficient as any other. (https://go.dev/play/p/lvY_5h-qPPf). While dst normally escapes to the heap, in practice the X25519 body will be inlined in the caller along with the dst allocation, and if the caller is careful not to let it escape, it will stay on the caller's stack. It will be as if the caller were using the hidden, less ergonomic, and more efficient x25519 API.",
            "tags": ["programming", "go"]
        },
        {
            "title": "Consistencies",
            "body": "Monotonic Writes - A write operation by a process on a data item x is completed before any successive write operation on x by the same process.\nRead your writes → The effect of a write operation by a process on data item x will always be seen by a successive read operation on x by the same process\nWrites follow reads → A write operation by a process on a data item x following a previous read operation on x by the same process is guaranteed to take place on the same or a more recent value of x that was read",
            "tags": ["distributed systems", "database"]
        },
        {
            "title": "ACID Properties:",
            "body": "Atomic: To the outside world, the transaction happens indivisibly\nConsistent: The transaction does not violate system invariants\n\nIsolated: Concurrent transactions do not interfere with each other\nDurable: Once a transmission commits, the changes are permanent.",
            "tags": ["distributed systems", "database"]
        },
        {
            "title": "Generics implementation - GC Shape Stenciling",
            "body": "https://go.googlesource.com/proposal/+/refs/heads/master/design/generics-implementation-gcshape.md",
            "tags": ["programming", "go"]
        },
        {
            "title": "Live Reloading Function",
            "body": "Live reloading refers to the ability of a software application to automatically refresh the user interface when changes are made to the underlying code. This can be a useful feature for developers, as it allows them to make changes to the code and see the results of those changes in real-time, without having to manually refresh the page or application. Live reloading can be implemented in a variety of ways, depending on the specific requirements of the application and the tools and technologies being used. In general, live reloading involves setting up a process that monitors the codebase for changes, and automatically triggers a refresh of the user interface when changes are detected.",
            "tags": ["programming"]
        },
        {
            "title": "Type Embedding in Go",
            "body": "We use embedding to promote all the fields and methods of an embedded type",
            "tags": ["programming", "go"]
        },
        {
            "title": "[GO] Slices",
            "body": "In Go a slice is backed by an array. That means the slice’s data is stored contiguously in an array data structure. A slice also handles the logic of adding an element if the backing array is full or shrinking the backing array if it’s almost empty. Internally a slice holds a pointer to the backing array plus a length and a capacity. `arr := make([]int, 5, 10)` The first argument, representing the len is mandatory, the second, the capacity, is optional. 2 slices referring to the same backing array → if we change `s1[i]` or `s2[j]` where `&s1[i] = &s2[j]` the effect will be visible on both slices. \ntip: if a function returns a slice, we should favor returning a nil slice instead of an empty slice",
            "tags": ["programming", "go"]
        },
        {
            "title": "[GO] Interfaces",
            "body": "We use interfaces to create common abstractions that multiple objects can implements. Go interfaces are different because they are satisfied implicitly. There is no explicit keyword like `implements` to mark that an object x implements interface y.",
            "tags": ["programming", "go"]
        },
        {
            "title": "[GO] Map",
            "body": "A map provides an unordered collection of key-value pairs in which all the keys are distinct. In Go, a map is based on the hash table data structure. Internally, a hash table is an array of buckets, and each bucket is a pointer to an array of key-value pairs. In case of insertion in a full bucket (bucket overflow), go creates another bucket of eight elements and links the previous bucket to it.\n Tip: a map can always grow in memory, but it never shrinks. Hence, if it leads to some memory issues, you can try different options, such as forcing Go to recreate the map or using pointers.",
            "tags": ["programming", "go"]
        },
        {
            "title": "[GO] Garbage Collection",
            "body": "Garbage collection is a form of automatic memory management, which reclaims memory occupied by objects that are no longer in use by the program. In Go, garbage collection (GC) is implemented using the mark-sweep algorithm.\n Go's GC is a concurrent, generational, and incremental garbage collector. It is concurrent in that it runs in parallel with the main program, thus reducing the amount of time spent on GC. Generational GC divides the heap into two parts: a young generation, which contains recently created objects, and an old generation, which contains objects that have been around for a while. The young generation is collected more frequently than the old, as most objects are short-lived. GC is incremental in that it splits its work into small, frequent iterations, which makes it less disruptive to the program.\n Finally, Go has a `stop-the-world` mechanism, which pauses the program while the GC is running. This ensures that the GC can safely access all the objects in the heap without being disturbed.\n Go's GC is designed to be efficient and unobtrusive. It minimizes the time spent on GC by running in parallel with the main program, and it is incremental, so it runs in small, frequent iterations that don't disrupt the program. Additionally, the stop-the-world mechanism pauses the program during GC, so that the GC can safely access all the objects in the heap.\n By employing the mark-sweep algorithm, Go's garbage collection (GC) is a concurrent, generational, and incremental garbage collector. It is designed to be efficient and unobtrusive, as it runs in parallel with the main program and takes only small, frequent iterations to complete. Additionally, it pauses the program during GC through its `stop-the-world` mechanism, allowing it to safely access all the objects in the heap.",
            "tags": ["programming", "go"]
        },
        {
            "title": "Rest API",
            "body": "A REST API (also known as RESTful API) is an application programming interface (API or web API) that conforms to the constraints of REST architectural style and allows for interaction with RESTful web services. REST stands for representational state transfer.",
            "tags": ["software architecture", "programming", "cloud"]
        },
        {
            "title": "Generics implementation - GC Shape Stenciling",
            "body": "a rune is a Unicode code point (commonly called character). A rune is an alias of int32. This is relevant because when we iterate over a string we have to keep in mind that we are iterating over the number of runes, not the bytes while some special characters (Æ) aren’t encoded in a single byte, it requires 2 bytes. So basically we badly encode that character.\n Runes are the way to refer to Unicode code points in Go and they are represented as an alias of int32. This is relevant when iterating over strings because some special characters require more than a single byte to be encoded. For example, the character Æ requires two bytes. In order to avoid badly encoding this character, we should use runes when iterating over strings.\n Moreover, runes are also essential for comparing strings, as they can be compared to each other directly. This increases the efficiency of string comparison operations, as the process does not need to be done byte-by-byte. Additionally, Unicode strings can be checked for equality using runes, as the process does not involve conversion to other encodings. Finally, runes are used extensively in regular expressions to match specific Unicode characters.\n Runes are also useful for manipulating strings. For example, they can be used to replace characters, as they are aware of the Unicode code points. This allows us to replace special characters without having to worry about encoding. Additionally, runes can also be used to extract substrings from strings, as they enable us to specify the exact index of the character to start from.",
            "tags": ["programming", "go"]
        }
    ]
}